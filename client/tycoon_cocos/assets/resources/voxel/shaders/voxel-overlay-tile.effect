CCEffect %{
  techniques:
  - name: overlay-opaque
    passes:
    - vert: vert
      frag: frag
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthTest: true
        depthWrite: true
      blendState:
        targets:
        - blend: false
    properties:
      mainTexture: { value: white }
      mainColor:   { value: [1.0, 1.0, 1.0, 1.0] }

  - name: overlay
    passes:
    - vert: vert
      frag: frag
      rasterizerState:
        cullMode: none            # 双面渲染，避免因顶点顺序差异被剔除
      depthStencilState:
        depthTest: true
        depthWrite: false         # 不写深度，避免覆盖地块
      blendState:
        targets:
        - blend: true
          blendEq: add
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendAlphaEq: add
          blendSrcAlpha: one
          blendDstAlpha: one_minus_src_alpha
    properties:
      mainTexture: { value: white }
      mainColor:   { value: [1.0, 1.0, 1.0, 1.0] } # w 作为整体透明度
    #priority: 255   # default 128 0 ~ 255
}%

CCProgram vert %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/uniforms/cc-local>
  in vec3 a_position;
  in vec2 a_texCoord;

  out vec2 v_uv;

  void main () {
    vec4 worldPos = cc_matWorld * vec4(a_position, 1.0);
    gl_Position = cc_matViewProj * worldPos;
    v_uv = a_texCoord;
  }
}%

CCProgram frag %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/uniforms/cc-local>

  in vec2 v_uv;

  uniform sampler2D mainTexture;
  uniform Constants {
    vec4 mainColor;
  };

  layout(location = 0) out vec4 fragColor;

  void main() {
    vec4 c = texture(mainTexture, v_uv);

    c *= mainColor;
    //if (c.a <= 0.01) discard;
    
    //fragColor = vec4(1.0, 0.0, 0.0, 1.0);

    fragColor = c;
  }
}%

