// Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: voxel-block-vs
      frag: voxel-block-fs
      rasterizerState:
        cullMode: back
      properties: &commonProps
        mainTexture:      { value: white }
        skyTexture:       { value: white }
        timer:            { value: 0.0 }
        daylight:         { value: 1.0 }
        fogDistance:      { value: 150.0 }
        ortho:            { value: 0 }
        
  - name: cutout
    passes:
    - vert: voxel-block-vs
      frag: voxel-cutout-fs
      rasterizerState:
        cullMode: none
      properties:
        <<: *commonProps
        alphaThreshold:   { value: 0.5 }
        
  - name: transparent
    passes:
    - vert: voxel-block-vs
      frag: voxel-transparent-fs
      priority: 200
      rasterizerState:
        cullMode: none
      depthStencilState:
        depthWrite: false
        depthFunc: less
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: one
          blendDstAlpha: one_minus_src_alpha
      properties:
        <<: *commonProps
        transparency:     { value: 0.8 }
}%

CCProgram voxel-block-vs %{
  precision mediump float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/uniforms/cc-local>
  
  uniform VoxelUniforms {
    float timer;
    float daylight;
    float fogDistance;
    float ortho;
  };

  in vec3 a_position;
  in vec3 a_normal;
  in vec2 a_texCoord;
  in float a_ao;
  in float a_light;

  out vec2 v_uv;
  out float v_ao;
  out float v_light;
  out float v_fogFactor;
  out float v_fogHeight;
  out float v_diffuse;

  const float PI = 3.14159265;
  const vec3 LIGHT_DIRECTION = normalize(vec3(-1.0, 1.0, -1.0));

  void main() {
    vec4 worldPos = cc_matWorld * vec4(a_position, 1.0);
    gl_Position = cc_matViewProj * worldPos;
    
    v_uv = a_texCoord;
    v_ao = 0.3 + (1.0 - a_ao) * 0.7;
    v_light = a_light;
    
    vec3 worldNormal = normalize((cc_matWorld * vec4(a_normal, 0.0)).xyz);
    v_diffuse = max(0.0, dot(worldNormal, LIGHT_DIRECTION));
    
    if (ortho > 0.5) {
      v_fogFactor = 0.0;
      v_fogHeight = 0.0;
    } else {
      float cameraDistance = distance(cc_cameraPos.xyz, worldPos.xyz);
      v_fogFactor = pow(clamp(cameraDistance / fogDistance, 0.0, 1.0), 4.0);
      
      float dy = worldPos.y - cc_cameraPos.y;
      float dx = distance(worldPos.xz, cc_cameraPos.xz);
      v_fogHeight = (atan(dy, dx) + PI / 2.0) / PI;
    }
  }
}%

CCProgram voxel-block-fs %{
  precision mediump float;
  #include <builtin/uniforms/cc-global>
  
  uniform sampler2D mainTexture;
  uniform sampler2D skyTexture;
  
  uniform VoxelUniforms {
    float timer;
    float daylight;
    float fogDistance;
    float ortho;
  };

  in vec2 v_uv;
  in float v_ao;
  in float v_light;
  in float v_fogFactor;
  in float v_fogHeight;
  in float v_diffuse;

  layout(location = 0) out vec4 fragColor;

  vec3 calculateLighting(vec4 texColor, float ao, float diffuse, float light) {
    bool isCloud = all(equal(texColor.rgb, vec3(1.0, 1.0, 1.0)));
    if (isCloud && ortho > 0.5) {
      discard;
    }
    
    // 检测是否为发光方块（light > 0.1 认为是发光方块）
    bool isEmissive = light > 0.1;
    
    float df = isCloud ? 1.0 - diffuse * 0.2 : diffuse;
    float aoFinal = isCloud ? 1.0 - (1.0 - ao) * 0.2 : ao;
    
    // 发光方块的AO和漫反射处理
    if (isEmissive) {
      // 发光方块减少AO的影响，让它们更亮
      aoFinal = mix(aoFinal, 1.0, light * 0.8);
      // 发光方块有基础光照，减少对环境光的依赖
      df = mix(df, 1.0, light * 0.6);
    }
    
    // 光照计算
    float lightValue = min(1.0, daylight + light);
    
    // 环境光：发光方块有更高的基础亮度
    vec3 ambient = vec3(lightValue * 0.4 + (isEmissive ? 0.4 : 0.15));
    
    // 方向光：发光方块自发光，减少方向光依赖
    vec3 directional = vec3(lightValue * 0.4 + 0.1) * df;
    
    // 自发光：发光方块添加额外的发光效果
    vec3 emissive = isEmissive ? texColor.rgb * light * 0.6 : vec3(0.0);
    
    // 最终光照 = 环境光 + 方向光 + 自发光
    vec3 lightFinal = ambient + directional + emissive;
    
    // 应用AO
    vec3 finalColor = texColor.rgb * lightFinal * aoFinal;
    
    // 发光方块确保最低亮度
    if (isEmissive) {
      finalColor = max(finalColor, texColor.rgb * 0.7 * light);
    }
    
    return clamp(finalColor, vec3(0.0), vec3(1.0));
  }

  void main() {
    vec4 texColor = texture(mainTexture, v_uv);
    
    if (all(equal(texColor.rgb, vec3(1.0, 0.0, 1.0)))) {
      discard;
    }
    
    vec3 finalColor = calculateLighting(texColor, v_ao, v_diffuse, v_light);
    
    vec3 skyColor = texture(skyTexture, vec2(timer, v_fogHeight)).rgb;
    finalColor = mix(finalColor, skyColor, clamp(v_fogFactor, 0.0, 1.0));
    
    fragColor = vec4(finalColor, texColor.a);
  }
}%

CCProgram voxel-cutout-fs %{
  precision mediump float;
  #include <builtin/uniforms/cc-global>
  
  uniform sampler2D mainTexture;
  uniform sampler2D skyTexture;
  
  uniform VoxelUniforms {
    float timer;
    float daylight;
    float fogDistance;
    float ortho;
  };
  uniform CutoutParams {
    float alphaThreshold;
  };

  in vec2 v_uv;
  in float v_ao;
  in float v_light;
  in float v_fogFactor;
  in float v_fogHeight;
  in float v_diffuse;

  layout(location = 0) out vec4 fragColor;

  vec3 calculateLighting(vec4 texColor, float ao, float diffuse, float light) {
    // 检测是否为发光方块
    bool isEmissive = light > 0.1;
    
    float df = diffuse;
    float aoFinal = ao;
    
    // 发光方块的AO和漫反射处理  
    if (isEmissive) {
      aoFinal = mix(aoFinal, 1.0, light * 0.8);
      df = mix(df, 1.0, light * 0.6);
    }
    
    // 光照计算
    float lightValue = min(1.0, daylight + light);
    
    // 环境光和方向光
    vec3 ambient = vec3(lightValue * 0.4 + (isEmissive ? 0.4 : 0.15));
    vec3 directional = vec3(lightValue * 0.4 + 0.1) * df;
    
    // 自发光效果
    vec3 emissive = isEmissive ? texColor.rgb * light * 0.6 : vec3(0.0);
    
    vec3 lightFinal = ambient + directional + emissive;
    vec3 finalColor = texColor.rgb * lightFinal * aoFinal;
    
    // 发光方块确保最低亮度
    if (isEmissive) {
      finalColor = max(finalColor, texColor.rgb * 0.7 * light);
    }
    
    return clamp(finalColor, vec3(0.0), vec3(1.0));
  }

  void main() {
    vec4 texColor = texture(mainTexture, v_uv);
    
    if (texColor.a < alphaThreshold) {
      discard;
    }
    
    if (all(equal(texColor.rgb, vec3(1.0, 0.0, 1.0)))) {
      discard;
    }
    
    vec3 finalColor = calculateLighting(texColor, v_ao, v_diffuse, v_light);
    
    vec3 skyColor = texture(skyTexture, vec2(timer, v_fogHeight)).rgb;
    finalColor = mix(finalColor, skyColor, clamp(v_fogFactor, 0.0, 1.0));
    
    fragColor = vec4(finalColor, 1.0);
  }
}%

CCProgram voxel-transparent-fs %{
  precision mediump float;
  #include <builtin/uniforms/cc-global>
  
  uniform sampler2D mainTexture;
  uniform sampler2D skyTexture;
  
  uniform VoxelUniforms {
    float timer;
    float daylight;
    float fogDistance;
    float ortho;
  };
  uniform TransparentParams {
    float transparency;
  };

  in vec2 v_uv;
  in float v_ao;
  in float v_light;
  in float v_fogFactor;
  in float v_fogHeight;
  in float v_diffuse;

  layout(location = 0) out vec4 fragColor;

  vec3 calculateLighting(vec4 texColor, float ao, float diffuse, float light) {
    // 检测是否为发光方块
    bool isEmissive = light > 0.1;
    
    float df = diffuse;
    float aoFinal = ao;
    
    // 发光方块的AO和漫反射处理
    if (isEmissive) {
      aoFinal = mix(aoFinal, 1.0, light * 0.8);
      df = mix(df, 1.0, light * 0.6);
    }
    
    // 光照计算
    float lightValue = min(1.0, daylight + light);
    
    // 环境光和方向光（透明方块稍微提高基础亮度）
    vec3 ambient = vec3(lightValue * 0.5 + (isEmissive ? 0.4 : 0.2));
    vec3 directional = vec3(lightValue * 0.3 + 0.1) * df * 0.8;
    
    // 自发光效果
    vec3 emissive = isEmissive ? texColor.rgb * light * 0.6 : vec3(0.0);
    
    vec3 lightFinal = ambient + directional + emissive;
    vec3 finalColor = texColor.rgb * lightFinal * aoFinal;
    
    // 发光方块确保最低亮度
    if (isEmissive) {
      finalColor = max(finalColor, texColor.rgb * 0.7 * light);
    }
    
    return clamp(finalColor, vec3(0.0), vec3(1.0));
  }

  void main() {
    vec4 texColor = texture(mainTexture, v_uv);
    
    if (all(equal(texColor.rgb, vec3(1.0, 0.0, 1.0)))) {
      discard;
    }
    
    vec3 finalColor = calculateLighting(texColor, v_ao, v_diffuse, v_light);
    
    vec3 skyColor = texture(skyTexture, vec2(timer, v_fogHeight)).rgb;
    finalColor = mix(finalColor, skyColor, clamp(v_fogFactor * 0.5, 0.0, 1.0));
    
    float alpha = texColor.a * transparency;
    fragColor = vec4(finalColor, alpha);
  }
}%