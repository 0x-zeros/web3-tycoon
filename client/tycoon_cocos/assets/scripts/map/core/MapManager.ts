/**
 * 地图管理器
 * 
 * 负责地图的加载、渲染、玩家移动路径计算等核心功能
 * 作为地图系统的中央控制器，协调各个地块和玩家的交互
 * 
 * @author Web3 Tycoon Team
 * @version 1.0.0
 */

import { _decorator, Component, Node, Vec3, Camera, geometry, PhysicsSystem, resources, JsonAsset, instantiate, Prefab, tween } from 'cc';\nimport { MapData, MapTileData, TileType, PathResult } from '../types/MapTypes';\nimport { PlayerData } from '../types/GameTypes';\nimport { MapTile, TileInteractionResult } from './MapTile';\n\nconst { ccclass, property } = _decorator;\n\n/**\n * 地图加载配置接口\n */\ninterface MapLoadConfig {\n    /** 地图数据文件路径 */\n    mapDataPath: string;\n    /** 地块预制件路径映射 */\n    tilePrefabPaths: { [key in TileType]: string };\n    /** 是否启用动画加载 */\n    enableLoadAnimation: boolean;\n    /** 加载动画持续时间 */\n    loadAnimationDuration: number;\n}\n\n/**\n * 玩家移动配置接口\n */\ninterface PlayerMovementConfig {\n    /** 移动速度（单位/秒） */\n    moveSpeed: number;\n    /** 移动动画类型 */\n    animationType: 'linear' | 'smooth' | 'bounce';\n    /** 是否显示移动路径 */\n    showMovePath: boolean;\n    /** 路径高亮颜色 */\n    pathHighlightColor: string;\n}\n\n/**\n * 摄像机控制配置接口\n */\ninterface CameraControlConfig {\n    /** 是否启用摄像机控制 */\n    enableCameraControl: boolean;\n    /** 缩放范围 */\n    zoomRange: { min: number; max: number };\n    /** 旋转范围 */\n    rotationRange: { min: number; max: number };\n    /** 移动边界 */\n    moveBounds: { x: number; z: number };\n    /** 控制敏感度 */\n    sensitivity: number;\n}\n\n/**\n * 地图管理器主类\n * 继承自Cocos Creator Component，可挂载到场景节点\n */\n@ccclass('MapManager')\nexport class MapManager extends Component {\n    \n    // ========================= 编辑器属性 =========================\n    \n    @property({ displayName: \"地图数据文件\", tooltip: \"JSON格式的地图数据文件路径\" })\n    public mapDataPath: string = 'data/maps/test_map';\n    \n    @property({ displayName: \"地块容器节点\", type: Node, tooltip: \"用于放置所有地块的父节点\" })\n    public tilesContainer: Node | null = null;\n    \n    @property({ displayName: \"主摄像机\", type: Camera, tooltip: \"场景主摄像机\" })\n    public mainCamera: Camera | null = null;\n    \n    @property({ displayName: \"启用鼠标控制\", tooltip: \"是否启用鼠标点击和拖拽控制\" })\n    public enableMouseControl: boolean = true;\n    \n    @property({ displayName: \"移动速度\", tooltip: \"玩家移动动画速度\" })\n    public playerMoveSpeed: number = 3.0;\n    \n    @property({ displayName: \"启用调试模式\", tooltip: \"显示调试信息和辅助线\" })\n    public debugMode: boolean = false;\n    \n    // ========================= 地块预制件引用 =========================\n    \n    @property({ displayName: \"起点地块预制件\", type: Prefab })\n    public startTilePrefab: Prefab | null = null;\n    \n    @property({ displayName: \"地产地块预制件\", type: Prefab })\n    public propertyTilePrefab: Prefab | null = null;\n    \n    @property({ displayName: \"机会地块预制件\", type: Prefab })\n    public chanceTilePrefab: Prefab | null = null;\n    \n    @property({ displayName: \"空白地块预制件\", type: Prefab })\n    public emptyTilePrefab: Prefab | null = null;\n    \n    @property({ displayName: \"监狱地块预制件\", type: Prefab })\n    public jailTilePrefab: Prefab | null = null;\n    \n    // ========================= 私有属性 =========================\n    \n    /** 当前地图数据 */\n    private _mapData: MapData | null = null;\n    \n    /** 地块实例映射表 */\n    private _tileInstances: Map<number, MapTile> = new Map();\n    \n    /** 地块节点映射表 */\n    private _tileNodes: Map<number, Node> = new Map();\n    \n    /** 路径缓存 */\n    private _pathCache: Map<string, PathResult> = new Map();\n    \n    /** 是否已初始化 */\n    private _isInitialized: boolean = false;\n    \n    /** 当前选中的地块 */\n    private _selectedTile: MapTile | null = null;\n    \n    /** 移动配置 */\n    private _moveConfig: PlayerMovementConfig = {\n        moveSpeed: 3.0,\n        animationType: 'smooth',\n        showMovePath: true,\n        pathHighlightColor: '#ffff00'\n    };\n    \n    /** 摄像机控制配置 */\n    private _cameraConfig: CameraControlConfig = {\n        enableCameraControl: true,\n        zoomRange: { min: 2, max: 10 },\n        rotationRange: { min: 0, max: 360 },\n        moveBounds: { x: 20, z: 20 },\n        sensitivity: 1.0\n    };\n    \n    /** 鼠标控制状态 */\n    private _mouseControlState = {\n        isDragging: false,\n        lastMousePos: Vec3.ZERO.clone(),\n        dragStartPos: Vec3.ZERO.clone()\n    };\n    \n    // ========================= 生命周期方法 =========================\n    \n    protected onLoad(): void {\n        this.initializeComponents();\n        this.setupMouseEvents();\n    }\n    \n    protected start(): void {\n        // 延迟一帧确保所有组件准备就绪\n        this.scheduleOnce(() => {\n            this.initializeMap();\n        }, 0);\n    }\n    \n    protected onDestroy(): void {\n        this.cleanup();\n    }\n    \n    // ========================= 初始化方法 =========================\n    \n    /**\n     * 初始化组件\n     */\n    private initializeComponents(): void {\n        // 创建地块容器（如果不存在）\n        if (!this.tilesContainer) {\n            this.tilesContainer = new Node('TilesContainer');\n            this.tilesContainer.setParent(this.node);\n        }\n        \n        // 获取主摄像机（如果不存在）\n        if (!this.mainCamera) {\n            this.mainCamera = this.node.getComponentInChildren(Camera);\n            if (!this.mainCamera) {\n                console.warn('[MapManager] 未找到主摄像机，某些功能可能无法正常工作');\n            }\n        }\n        \n        // 更新移动配置\n        this._moveConfig.moveSpeed = this.playerMoveSpeed;\n        \n        console.log('[MapManager] 组件初始化完成');\n    }\n    \n    /**\n     * 设置鼠标事件\n     */\n    private setupMouseEvents(): void {\n        if (!this.enableMouseControl) {\n            return;\n        }\n        \n        // TODO: 根据Cocos Creator版本调整事件处理方式\n        // 这里需要在Canvas或者其他合适的节点上监听全局鼠标事件\n        this.node.on(Node.EventType.MOUSE_DOWN, this.onMouseDown, this);\n        this.node.on(Node.EventType.MOUSE_MOVE, this.onMouseMove, this);\n        this.node.on(Node.EventType.MOUSE_UP, this.onMouseUp, this);\n        this.node.on(Node.EventType.MOUSE_WHEEL, this.onMouseWheel, this);\n    }\n    \n    /**\n     * 初始化地图\n     */\n    private async initializeMap(): Promise<void> {\n        try {\n            console.log('[MapManager] 开始加载地图...');\n            \n            // 加载地图数据\n            await this.loadMapData();\n            \n            // 创建地块\n            await this.createTiles();\n            \n            // 设置摄像机位置\n            this.setupCamera();\n            \n            // 缓存路径\n            this.buildPathCache();\n            \n            this._isInitialized = true;\n            \n            console.log('[MapManager] 地图初始化完成');\n            \n            // 触发地图加载完成事件\n            this.node.emit('map-loaded', { mapData: this._mapData });\n            \n        } catch (error) {\n            console.error('[MapManager] 地图初始化失败:', error);\n            this.node.emit('map-load-error', { error });\n        }\n    }\n    \n    /**\n     * 加载地图数据\n     */\n    private async loadMapData(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            resources.load(this.mapDataPath, JsonAsset, (err, jsonAsset) => {\n                if (err) {\n                    console.error('[MapManager] 加载地图数据失败:', err);\n                    reject(err);\n                    return;\n                }\n                \n                try {\n                    this._mapData = jsonAsset.json as MapData;\n                    console.log('[MapManager] 地图数据加载成功:', this._mapData.metadata.name);\n                    resolve();\n                } catch (parseError) {\n                    console.error('[MapManager] 解析地图数据失败:', parseError);\n                    reject(parseError);\n                }\n            });\n        });\n    }\n    \n    /**\n     * 创建所有地块\n     */\n    private async createTiles(): Promise<void> {\n        if (!this._mapData || !this.tilesContainer) {\n            throw new Error('地图数据或容器节点不存在');\n        }\n        \n        const promises: Promise<void>[] = [];\n        \n        for (const tileData of this._mapData.tiles) {\n            promises.push(this.createSingleTile(tileData));\n        }\n        \n        await Promise.all(promises);\n        \n        console.log(`[MapManager] 创建了 ${this._tileInstances.size} 个地块`);\n    }\n    \n    /**\n     * 创建单个地块\n     */\n    private async createSingleTile(tileData: MapTileData): Promise<void> {\n        const prefab = this.getTilePrefab(tileData.type);\n        if (!prefab) {\n            console.error(`[MapManager] 找不到地块类型 ${tileData.type} 的预制件`);\n            return;\n        }\n        \n        // 实例化预制件\n        const tileNode = instantiate(prefab);\n        tileNode.name = `Tile_${tileData.id}_${tileData.name}`;\n        tileNode.setParent(this.tilesContainer!);\n        \n        // 获取MapTile组件\n        const tileComponent = tileNode.getComponent(MapTile);\n        if (!tileComponent) {\n            console.error(`[MapManager] 地块预制件 ${tileData.type} 缺少MapTile组件`);\n            tileNode.destroy();\n            return;\n        }\n        \n        // 初始化地块数据\n        tileComponent.initializeTile(tileData);\n        \n        // 监听地块事件\n        tileNode.on('game-event', this.onTileEvent, this);\n        \n        // 保存引用\n        this._tileInstances.set(tileData.id, tileComponent);\n        this._tileNodes.set(tileData.id, tileNode);\n        \n        if (this.debugMode) {\n            console.log(`[MapManager] 创建地块: ${tileData.name} (${tileData.type})`);\n        }\n    }\n    \n    /**\n     * 获取地块类型对应的预制件\n     */\n    private getTilePrefab(tileType: TileType): Prefab | null {\n        switch (tileType) {\n            case TileType.START:\n                return this.startTilePrefab;\n            case TileType.PROPERTY:\n                return this.propertyTilePrefab;\n            case TileType.CHANCE:\n                return this.chanceTilePrefab;\n            case TileType.EMPTY:\n                return this.emptyTilePrefab;\n            case TileType.JAIL:\n                return this.jailTilePrefab;\n            default:\n                console.warn(`[MapManager] 未支持的地块类型: ${tileType}`);\n                return this.emptyTilePrefab; // 默认使用空白地块\n        }\n    }\n    \n    /**\n     * 设置摄像机\n     */\n    private setupCamera(): void {\n        if (!this.mainCamera || !this._mapData) {\n            return;\n        }\n        \n        // 如果地图数据中有摄像机配置，使用配置的位置\n        if (this._mapData.sceneConfig?.cameraPosition) {\n            this.mainCamera.node.setPosition(this._mapData.sceneConfig.cameraPosition);\n        } else {\n            // 否则计算地图中心位置\n            const center = this.calculateMapCenter();\n            this.mainCamera.node.setPosition(center.x, 8, center.z + 5); // 45度俯视角度\n            this.mainCamera.node.setRotationFromEuler(45, 0, 0);\n        }\n        \n        console.log('[MapManager] 摄像机设置完成');\n    }\n    \n    /**\n     * 计算地图中心位置\n     */\n    private calculateMapCenter(): Vec3 {\n        if (!this._mapData || this._mapData.tiles.length === 0) {\n            return Vec3.ZERO;\n        }\n        \n        let minX = Infinity, maxX = -Infinity;\n        let minZ = Infinity, maxZ = -Infinity;\n        \n        for (const tile of this._mapData.tiles) {\n            minX = Math.min(minX, tile.position.x);\n            maxX = Math.max(maxX, tile.position.x);\n            minZ = Math.min(minZ, tile.position.z);\n            maxZ = Math.max(maxZ, tile.position.z);\n        }\n        \n        return new Vec3(\n            (minX + maxX) / 2,\n            0,\n            (minZ + maxZ) / 2\n        );\n    }\n    \n    /**\n     * 构建路径缓存\n     */\n    private buildPathCache(): void {\n        if (!this._mapData) {\n            return;\n        }\n        \n        console.log('[MapManager] 开始构建路径缓存...');\n        \n        // 为常用路径组合建立缓存\n        // 这里可以预计算一些常用的路径，提高运行时性能\n        const tileIds = this._mapData.tiles.map(t => t.id);\n        \n        // 缓存相邻地块的路径（距离为1-6步的路径）\n        for (let i = 0; i < tileIds.length; i++) {\n            const fromId = tileIds[i];\n            for (let steps = 1; steps <= 6; steps++) {\n                const path = this.calculateMovePath(fromId, steps);\n                const cacheKey = `${fromId}-${steps}`;\n                this._pathCache.set(cacheKey, path);\n            }\n        }\n        \n        console.log(`[MapManager] 路径缓存构建完成，缓存了 ${this._pathCache.size} 条路径`);\n    }\n    \n    // ========================= 公共接口方法 =========================\n    \n    /**\n     * 获取地块实例\n     * @param tileId 地块ID\n     */\n    public getTile(tileId: number): MapTile | null {\n        return this._tileInstances.get(tileId) || null;\n    }\n    \n    /**\n     * 获取地块节点\n     * @param tileId 地块ID\n     */\n    public getTileNode(tileId: number): Node | null {\n        return this._tileNodes.get(tileId) || null;\n    }\n    \n    /**\n     * 获取起点地块\n     */\n    public getStartTile(): MapTile | null {\n        if (!this._mapData) {\n            return null;\n        }\n        \n        return this.getTile(this._mapData.startTileId);\n    }\n    \n    /**\n     * 计算玩家移动路径\n     * @param fromTileId 起始地块ID\n     * @param steps 移动步数\n     */\n    public calculateMovePath(fromTileId: number, steps: number): PathResult {\n        const cacheKey = `${fromTileId}-${steps}`;\n        \n        // 检查缓存\n        if (this._pathCache.has(cacheKey)) {\n            return this._pathCache.get(cacheKey)!;\n        }\n        \n        // 计算路径\n        const path = this.computeMovePath(fromTileId, steps);\n        \n        // 缓存结果\n        this._pathCache.set(cacheKey, path);\n        \n        return path;\n    }\n    \n    /**\n     * 实际计算移动路径的逻辑\n     */\n    private computeMovePath(fromTileId: number, steps: number): PathResult {\n        if (!this._mapData) {\n            return { tileIds: [], totalDistance: 0, isValid: false };\n        }\n        \n        const tileIds: number[] = [fromTileId];\n        let currentTileId = fromTileId;\n        let remainingSteps = steps;\n        \n        while (remainingSteps > 0) {\n            const currentTile = this._mapData.tiles.find(t => t.id === currentTileId);\n            if (!currentTile) {\n                console.error(`[MapManager] 找不到地块 ID: ${currentTileId}`);\n                return { tileIds: [], totalDistance: 0, isValid: false };\n            }\n            \n            const nextTileId = currentTile.nextTileId;\n            tileIds.push(nextTileId);\n            currentTileId = nextTileId;\n            remainingSteps--;\n        }\n        \n        return {\n            tileIds: tileIds.slice(1), // 移除起点\n            totalDistance: steps,\n            isValid: true\n        };\n    }\n    \n    /**\n     * 玩家移动到指定地块\n     * @param player 玩家数据\n     * @param targetTileId 目标地块ID\n     * @param animated 是否播放移动动画\n     */\n    public async movePlayerToTile(player: PlayerData, targetTileId: number, animated: boolean = true): Promise<TileInteractionResult> {\n        const targetTile = this.getTile(targetTileId);\n        if (!targetTile) {\n            console.error(`[MapManager] 目标地块不存在: ${targetTileId}`);\n            return {\n                success: false,\n                message: '目标地块不存在',\n                events: []\n            };\n        }\n        \n        // 从当前地块离开\n        const currentTile = this.getTile(player.currentTileId);\n        if (currentTile) {\n            currentTile.playerLeave(player);\n        }\n        \n        // 播放移动动画（如果启用）\n        if (animated && player.pieceNode) {\n            await this.playMoveAnimation(player.pieceNode, targetTile.getWorldPosition());\n        }\n        \n        // 到达新地块\n        const result = await targetTile.playerLandOn(player);\n        \n        console.log(`[MapManager] 玩家 ${player.nickname} 移动到地块 ${targetTile.getTileInfo().name}`);\n        \n        return result;\n    }\n    \n    /**\n     * 沿路径移动玩家\n     * @param player 玩家数据\n     * @param path 移动路径\n     */\n    public async movePlayerAlongPath(player: PlayerData, path: PathResult): Promise<TileInteractionResult[]> {\n        if (!path.isValid || path.tileIds.length === 0) {\n            return [];\n        }\n        \n        const results: TileInteractionResult[] = [];\n        \n        // 依次经过路径上的每个地块\n        for (let i = 0; i < path.tileIds.length; i++) {\n            const tileId = path.tileIds[i];\n            const tile = this.getTile(tileId);\n            \n            if (!tile) {\n                console.error(`[MapManager] 路径上的地块不存在: ${tileId}`);\n                continue;\n            }\n            \n            const isLastTile = i === path.tileIds.length - 1;\n            \n            if (isLastTile) {\n                // 最后一个地块：停留\n                const result = await this.movePlayerToTile(player, tileId, true);\n                results.push(result);\n            } else {\n                // 中间地块：经过\n                const result = await tile.playerPassThrough(player);\n                results.push(result);\n                \n                // 播放经过动画\n                if (player.pieceNode) {\n                    await this.playMoveAnimation(player.pieceNode, tile.getWorldPosition(), 0.3);\n                }\n            }\n        }\n        \n        return results;\n    }\n    \n    /**\n     * 播放移动动画\n     * @param pieceNode 棋子节点\n     * @param targetPosition 目标位置\n     * @param duration 动画时长\n     */\n    private async playMoveAnimation(pieceNode: Node, targetPosition: Vec3, duration?: number): Promise<void> {\n        return new Promise((resolve) => {\n            const animDuration = duration || (1.0 / this._moveConfig.moveSpeed);\n            \n            tween(pieceNode)\n                .to(animDuration, { position: targetPosition })\n                .call(() => {\n                    resolve();\n                })\n                .start();\n        });\n    }\n    \n    /**\n     * 高亮显示路径\n     * @param path 要高亮的路径\n     */\n    public highlightPath(path: PathResult): void {\n        // 清除之前的高亮\n        this.clearPathHighlight();\n        \n        if (!path.isValid) {\n            return;\n        }\n        \n        // 高亮路径上的地块\n        for (const tileId of path.tileIds) {\n            const tile = this.getTile(tileId);\n            if (tile) {\n                tile.setHighlighted(true);\n            }\n        }\n    }\n    \n    /**\n     * 清除路径高亮\n     */\n    public clearPathHighlight(): void {\n        this._tileInstances.forEach(tile => {\n            tile.setHighlighted(false);\n        });\n    }\n    \n    /**\n     * 设置选中的地块\n     * @param tileId 地块ID\n     */\n    public setSelectedTile(tileId: number | null): void {\n        // 清除之前的选中状态\n        if (this._selectedTile) {\n            this._selectedTile.setSelected(false);\n        }\n        \n        // 设置新的选中状态\n        if (tileId !== null) {\n            this._selectedTile = this.getTile(tileId);\n            if (this._selectedTile) {\n                this._selectedTile.setSelected(true);\n            }\n        } else {\n            this._selectedTile = null;\n        }\n    }\n    \n    // ========================= 鼠标事件处理 =========================\n    \n    private onMouseDown(event: any): void {\n        if (!this.enableMouseControl) {\n            return;\n        }\n        \n        this._mouseControlState.isDragging = true;\n        this._mouseControlState.lastMousePos = event.getLocation();\n        this._mouseControlState.dragStartPos = event.getLocation();\n        \n        // 尝试射线检测选中地块\n        this.performRaycast(event);\n    }\n    \n    private onMouseMove(event: any): void {\n        if (!this.enableMouseControl || !this.mainCamera) {\n            return;\n        }\n        \n        const currentPos = event.getLocation();\n        \n        if (this._mouseControlState.isDragging) {\n            // 计算鼠标移动距离\n            const deltaX = currentPos.x - this._mouseControlState.lastMousePos.x;\n            const deltaY = currentPos.y - this._mouseControlState.lastMousePos.y;\n            \n            // 旋转摄像机\n            this.rotateCameraByDelta(deltaX, deltaY);\n            \n            this._mouseControlState.lastMousePos = currentPos;\n        }\n    }\n    \n    private onMouseUp(event: any): void {\n        this._mouseControlState.isDragging = false;\n    }\n    \n    private onMouseWheel(event: any): void {\n        if (!this.enableMouseControl || !this.mainCamera) {\n            return;\n        }\n        \n        // 缩放摄像机\n        const scrollY = event.getScrollY();\n        this.zoomCameraByDelta(scrollY);\n    }\n    \n    /**\n     * 执行射线检测\n     */\n    private performRaycast(event: any): void {\n        if (!this.mainCamera) {\n            return;\n        }\n        \n        // TODO: 实现射线检测逻辑\n        // 这里需要根据Cocos Creator的物理系统API来实现\n        // 基本流程是：鼠标位置 -> 世界坐标射线 -> 与地块碰撞检测\n        \n        console.log('[MapManager] 射线检测功能待实现');\n    }\n    \n    /**\n     * 根据鼠标移动旋转摄像机\n     */\n    private rotateCameraByDelta(deltaX: number, deltaY: number): void {\n        if (!this.mainCamera) {\n            return;\n        }\n        \n        const rotationSpeed = this._cameraConfig.sensitivity * 0.5;\n        const currentRotation = this.mainCamera.node.eulerAngles;\n        \n        // 水平旋转（绕Y轴）\n        let newRotationY = currentRotation.y + deltaX * rotationSpeed;\n        \n        // 垂直旋转（绕X轴）\n        let newRotationX = currentRotation.x - deltaY * rotationSpeed;\n        newRotationX = Math.max(10, Math.min(80, newRotationX)); // 限制俯仰角度\n        \n        this.mainCamera.node.setRotationFromEuler(newRotationX, newRotationY, 0);\n    }\n    \n    /**\n     * 根据鼠标滚轮缩放摄像机\n     */\n    private zoomCameraByDelta(scrollDelta: number): void {\n        if (!this.mainCamera) {\n            return;\n        }\n        \n        const zoomSpeed = this._cameraConfig.sensitivity * 0.5;\n        const currentPos = this.mainCamera.node.position;\n        const zoomDirection = currentPos.clone().normalize();\n        \n        // 计算新位置\n        const zoomAmount = scrollDelta * zoomSpeed;\n        const newPos = currentPos.clone().add(zoomDirection.multiplyScalar(zoomAmount));\n        \n        // 限制缩放范围\n        const distance = newPos.length();\n        if (distance >= this._cameraConfig.zoomRange.min && distance <= this._cameraConfig.zoomRange.max) {\n            this.mainCamera.node.setPosition(newPos);\n        }\n    }\n    \n    // ========================= 事件处理 =========================\n    \n    /**\n     * 处理来自地块的事件\n     */\n    private onTileEvent(event: any): void {\n        const { type, data, source } = event.detail || event;\n        \n        console.log(`[MapManager] 收到地块事件: ${type}`, data);\n        \n        // 转发给游戏管理器或其他系统\n        this.node.emit('tile-event', { type, data, source });\n    }\n    \n    // ========================= 工具方法 =========================\n    \n    /**\n     * 获取地图数据\n     */\n    public getMapData(): MapData | null {\n        return this._mapData;\n    }\n    \n    /**\n     * 检查是否已初始化\n     */\n    public isInitialized(): boolean {\n        return this._isInitialized;\n    }\n    \n    /**\n     * 获取所有地块\n     */\n    public getAllTiles(): MapTile[] {\n        return Array.from(this._tileInstances.values());\n    }\n    \n    /**\n     * 清理资源\n     */\n    private cleanup(): void {\n        // 清理缓存\n        this._pathCache.clear();\n        this._tileInstances.clear();\n        this._tileNodes.clear();\n        \n        // 移除事件监听\n        if (this.node.isValid) {\n            this.node.off(Node.EventType.MOUSE_DOWN, this.onMouseDown, this);\n            this.node.off(Node.EventType.MOUSE_MOVE, this.onMouseMove, this);\n            this.node.off(Node.EventType.MOUSE_UP, this.onMouseUp, this);\n            this.node.off(Node.EventType.MOUSE_WHEEL, this.onMouseWheel, this);\n        }\n        \n        console.log('[MapManager] 资源清理完成');\n    }\n    \n    /**\n     * 重新加载地图\n     */\n    public async reloadMap(): Promise<void> {\n        this.cleanup();\n        this._isInitialized = false;\n        await this.initializeMap();\n    }\n}