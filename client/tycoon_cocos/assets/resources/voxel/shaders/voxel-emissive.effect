// Copyright (c) 2017-2023 Xiamen Yaji Software Co., Ltd.
// 体素发光方块着色器 - 用于萤石、火把、岩浆等发光方块
CCEffect %{
  techniques:
  - name: emissive
    passes:
    - vert: voxel-emissive-vs
      frag: voxel-emissive-fs
      rasterizerState:
        cullMode: back
      depthStencilState:
        depthWrite: true
        depthFunc: less
      properties:
        mainTexture:        { value: white }
        skyTexture:         { value: white }
        timer:              { value: 0.0 }
        daylight:           { value: 1.0 }
        fogDistance:        { value: 150.0 }
        ortho:              { value: 0 }
        emissiveColor:      { value: [1.0, 0.8, 0.3, 1.0] }
        emissiveIntensity:  { value: 2.0 }
        flickerSpeed:       { value: 0.0 }
        flickerAmount:      { value: 0.0 }
        bloomIntensity:     { value: 1.0 }
}%

CCProgram voxel-emissive-vs %{
  precision mediump float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/uniforms/cc-local>
  
  uniform EmissiveVSUniforms {
    float timer;
    float daylight;
    float fogDistance;
    float ortho;
    float emissiveIntensity;
    float flickerSpeed;
    float flickerAmount;
  };

  in vec3 a_position;
  in vec3 a_normal;
  in vec2 a_texCoord;
  in float a_ao;
  in float a_light;

  out vec2 v_uv;
  out float v_ao;
  out float v_light;
  out float v_fogFactor;
  out float v_fogHeight;
  out float v_diffuse;
  out float v_flickerFactor;

  const float PI = 3.14159265;
  const vec3 LIGHT_DIRECTION = normalize(vec3(-1.0, 1.0, -1.0));

  void main() {
    vec4 worldPos = cc_matWorld * vec4(a_position, 1.0);
    gl_Position = cc_matViewProj * worldPos;
    
    v_uv = a_texCoord;
    v_ao = 0.3 + (1.0 - a_ao) * 0.7;
    v_light = a_light;
    
    vec3 worldNormal = normalize((cc_matWorld * vec4(a_normal, 0.0)).xyz);
    v_diffuse = max(0.0, dot(worldNormal, LIGHT_DIRECTION));
    
    if (flickerSpeed > 0.0) {
      float flicker1 = sin(timer * flickerSpeed);
      float flicker2 = sin(timer * flickerSpeed * 1.7 + 1.0);
      float flicker3 = sin(timer * flickerSpeed * 2.3 + 2.0);
      v_flickerFactor = 1.0 + (flicker1 + flicker2 * 0.5 + flicker3 * 0.3) * flickerAmount * 0.3;
      v_flickerFactor = clamp(v_flickerFactor, 0.5, 1.5);
    } else {
      v_flickerFactor = 1.0;
    }
    
    if (ortho > 0.5) {
      v_fogFactor = 0.0;
      v_fogHeight = 0.0;
    } else {
      float cameraDistance = distance(cc_cameraPos.xyz, worldPos.xyz);
      v_fogFactor = pow(clamp(cameraDistance / fogDistance, 0.0, 1.0), 6.0);
      
      float dy = worldPos.y - cc_cameraPos.y;
      float dx = distance(worldPos.xz, cc_cameraPos.xz);
      v_fogHeight = (atan(dy, dx) + PI / 2.0) / PI;
    }
  }
}%

CCProgram voxel-emissive-fs %{
  precision mediump float;
  #include <builtin/uniforms/cc-global>
  
  uniform sampler2D mainTexture;
  uniform sampler2D skyTexture;
  
  uniform EmissiveFSUniforms {
    float timer;
    float daylight;
    float fogDistance;
    float ortho;
    vec4 emissiveColor;
    float emissiveIntensity;
    float flickerSpeed;
    float flickerAmount;
    float bloomIntensity;
  };

  in vec2 v_uv;
  in float v_ao;
  in float v_light;
  in float v_fogFactor;
  in float v_fogHeight;
  in float v_diffuse;
  in float v_flickerFactor;

  layout(location = 0) out vec4 fragColor;

  void main() {
    vec4 texColor = texture(mainTexture, v_uv);
    
    if (all(equal(texColor.rgb, vec3(1.0, 0.0, 1.0)))) {
      discard;
    }
    
    float ao = v_ao;
    float df = v_diffuse * 0.3;
    
    ao = min(1.0, ao + v_light);
    df = min(1.0, df + v_light);
    
    float lightValue = min(1.0, daylight + v_light);
    vec3 ambient = vec3(lightValue * 0.1 + 0.1);
    vec3 diffuseLight = vec3(lightValue * 0.1) * df;
    
    vec3 baseColor = texColor.rgb * (ambient + diffuseLight) * ao;
    vec3 emissive = texColor.rgb * emissiveColor.rgb * emissiveIntensity * v_flickerFactor;
    
    vec3 finalColor = baseColor + emissive;
    finalColor = clamp(finalColor, vec3(0.0), vec3(10.0));
    
    vec3 skyColor = texture(skyTexture, vec2(timer, v_fogHeight)).rgb;
    finalColor = mix(finalColor, skyColor, clamp(v_fogFactor * 0.3, 0.0, 1.0));
    
    float brightness = dot(emissive, vec3(0.299, 0.587, 0.114)) * bloomIntensity;
    brightness = clamp(brightness, 0.0, 1.0);
    
    fragColor = vec4(finalColor, max(texColor.a, brightness));
  }
}%