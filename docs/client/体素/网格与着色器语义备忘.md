# 体素网格与着色器语义备忘（Cocos Creator 3.8）

目的：统一“网格数据 → 着色器语义”的映射，避免直接写只读属性（mesh.struct/data），并为后续扩展留出空间。

## 背景

- 引擎 3.8 中 `Mesh.struct` 和 `Mesh.data` 为只读。建议使用 `utils.MeshUtils.createMesh(...)`（或 `createDynamicMesh`）一次性注入几何数据。
- 官方文档：程序化创建网格（静态/动态网格）
  - https://docs.cocos.com/creator/3.8/manual/zh/asset/model/scripting-mesh.html
- 参考示例集合：
  - https://github.com/cocos/cocos-test-projects/tree/v3.8

## 标准语义与映射约定

当前实现统一遵循如下“标准语义映射”，尽量不引入自定义顶点语义，便于兼容与维护：

- a_position(vec3): 顶点位置
- a_normal(vec3): 顶点法线
- a_texCoord(vec2): 主 UV（uv0）
- a_texCoord1(vec2): 第二套 UV（uv1），用于 overlay/第二纹理坐标
- a_color(vec4): 顶点颜色，用于打包自定义标量
  - R 通道：AO（Ambient Occlusion）
  - G 通道：Light（顶点光照强度，0~1）
  - B 通道：预留（可扩展：湿度/群系色/金属度等）
  - A 通道：预留（通常填 1.0）

> 注意：若后续需要更多自定义数据，优先考虑继续复用 `a_color.b/a` 与 `a_texCoord2~a_texCoord7`，再考虑切换到更底层的自定义顶点声明。

## 代码位置与关键变更

- 网格组装（将自定义数据映射到标准语义）
  - `client/tycoon_cocos/assets/scripts/voxel/resource/MeshBuilder.ts`
    - 输出字段：`positions, normals, uvs, uvs1, colors, indices`
    - overlay UV → `uvs1`（供 `a_texCoord1` 使用）
    - AO/Light → `colors`（`a_color.r = AO`, `a_color.g = Light`）
    - 网格创建：`utils.MeshUtils.createMesh({ ... })`

- 着色器读取（从标准语义解包 AO/Light/overlay）
  - `client/tycoon_cocos/assets/resources/voxel/shaders/voxel-block.effect`
  - `client/tycoon_cocos/assets/resources/voxel/shaders/voxel-emissive.effect`
    - 新增输入：`in vec2 a_texCoord1; in vec4 a_color;`
    - AO：`v_ao = 0.3 + (1.0 - a_color.r) * 0.7;`
    - 光照：`v_light = a_color.g;`
    - overlay：使用 `a_texCoord1`（如需要在 FS 中进行第二纹理采样/混合）

## 发光效果约定

- 顶点光照（Light）参与基础光照调制，能实现简单“自发光”效果。
- 若需要更强的自发光/泛光，可按需使用 `voxel-emissive.effect`（材质层面切换到 emissive 技术），并设置：
  - 着色器属性：`emissiveColor`、`emissiveIntensity`、`bloomIntensity` 等
  - 材质工厂位置：`client/tycoon_cocos/assets/scripts/voxel/resource/MaterialFactory.ts`
    - 可在 `createBlockMaterial()` 根据 block/lightLevel 决定是否创建发光材质

## 使用示例（要点）

1) 组装网格数据（片段）：

```ts
// MeshBuilder 内部逻辑要点：
positions.push(px, py, pz);
normals.push(nx, ny, nz);
uvs.push(u, v);           // 主纹理UV → a_texCoord
uvs1.push(u1, v1);        // overlay UV → a_texCoord1
colors.push(ao, light, 0, 1); // a_color.r = AO, a_color.g = Light

const mesh = utils.MeshUtils.createMesh({ positions, normals, uvs, uvs1, colors, indices });
```

2) 顶点着色器读取（片段）：

```glsl
in vec2 a_texCoord;  // 主UV
in vec2 a_texCoord1; // overlay UV
in vec4 a_color;     // R=AO, G=Light

v_uv = a_texCoord;
v_ao = 0.3 + (1.0 - a_color.r) * 0.7;
v_light = a_color.g;
```

## 注意事项

- 不直接写 `mesh.struct`/`mesh.data`（只读）。统一通过 `MeshUtils.createMesh` 或 `createDynamicMesh` 创建。
- 顶点属性数量有限（WebGL2/GLES3 常见 16 个插槽），尽量打包标量（如使用 `a_color`）以减少属性数。
- 透明与双面材质请配合 Effect 中的 technique/渲染状态（`cullMode`、`depthWrite`、混合等）统一配置。

## 可扩展方向

- `a_color.b`/`a_color.a` 用于新标量（如湿度/群系色/金属度/粗糙度/特殊遮罩）。
- `a_texCoord2 ~ a_texCoord7`：动画参数、图集索引、风场采样坐标等。
- 切换 `createDynamicMesh`：若需要运行时频繁更新顶点数据。

---



### 不能自定义顶点格式吗？
可以，但不建议直接写 mesh.struct/mesh.data（它们在 3.8 是只读，需通过初始化或工具方法一次性注入）。更稳妥的两条路：
推荐做法（零侵入、兼容编辑器）
用官方支持的标准语义承载自定义数据，然后用着色器读取：
overlay UV 放到第二套 UV：uvs1
AO、Light 打包进顶点颜色：a_color.r = AO，a_color.g = Light
顶点侧用 utils.MeshUtils.createMesh({ positions, normals, uvs, uvs1, colors, indices }) 创建网格
着色器改成读取标准属性即可（顶点 VS）：
in vec2 a_texCoord1; 作为 overlay UV
in vec4 a_color; v_ao = a_color.r; v_light = a_color.g;
参考官方“程序化创建网格”说明（使用 MeshUtils 创建静态/动态网格）：
文档: Cocos Creator 3.8 程序化创建网格
低层自定义（真“自定义顶点格式”）
不在运行时修改只读属性，而是在创建时一次性用底层 gfx 接口/RenderingSubMesh 构建自定义 VertexBufferLayout 与 InputAssembler，并配套自定义着色器 attribute 声明。
这条路会绕开 MeshUtils，成本更高，也更容易与引擎版本耦合；建议参考官方测试工程里的底层用法范式再谨慎落地：
示例: cocos-test-projects v3.8
结论
可以自定义，但在 Creator 3.8 的推荐路径是“用标准语义映射”+“Effect 读这些语义”，既安全又可维护。


### a_texCoord ， a_texCoord 1～7都是 vec2吗？
是的：默认语义里 a_texCoord 与 a_texCoord1 ~ a_texCoord7 在 Creator 3.8 中按 UV 集合使用，惯例为 vec2。在 Mesh 侧分别对应 uvs, uvs1, …, uvs7，每组按 2 分量展开（[u, v, u, v, …]）。
如需 vec3/vec4 形式的“UV”，需走自定义 Attribute（自定义名称+gfx.Format），并在 effect 中用对应的 attribute 名读取，不再用 a_texCoord* 语义。
可查文档
程序化创建网格（MeshUtils、IGeometry 字段命名/用法）: https://docs.cocos.com/creator/3.8/manual/zh/asset/model/scripting-mesh.html
着色器/Effect 基本语法与内置 attribute 约定（创建与使用）: https://docs.cocos.com/creator/3.8/manual/zh/shader/index.html